# 题目思路列表

### 53 最大子序和
动态规划思路
emmm，待理解

### 70 爬楼梯
可以分成多个子问题， 爬1个楼梯的可能性 fn(n - 1) + 爬两个楼梯的可能性 fn(n - 2) 想加就是所有的可能，所以使用递归。

### 101 对称二叉树
第三层开始， 判断t1 和 t2 值是否相等，同时比较 t1 左节点 与 t2 右节点对比， t1 右节点 与 t2 左节点对比

### 104 二叉树的最大深度
分别递归左节点和右节点， 取两者大的那个值

### 121 买卖股票的最佳时机
遍历，获取最低值，然后与当前值对比，获取差值最大的zhi值，即买卖的最佳时机

### 136 只出现一次的数字
去异，就是这么简单，大概率不考

### 141 环形链表
1.遍历链表，放过某个节点， 则标记为 true， 当遍历过程中发现节点有标记访问过的节点，则说明是一个循环链表。
2.设置快慢指针，如果快慢相遇，则说明是循环链表

### 155 最小栈
通过数组模拟即可， push， 取数组最后一位，返回最小值

### 160 相交链表
1.遍历 A 链表，设置访问过节点 flag: true，  再遍历 B 链表，判断 B 链表中是否存在 Flag 为 true 的节点，有则说明第一个节点就是相交的第一个节点
2.两个链表从头遍历，当其中一条链表遍历到末尾时，跳到另一个链表重新遍历， 如果相交，最终一定会相等，因为两个指针走过的路程相同，如后面所示： a1a2c1c2b1b2b3,  b1b2b3c1c2a1a2，最终会在 c1 相等

### 169 多数元素
1.使用一个 map 来存储元素以及次数， 判断某个元素超过数组长度一半，则该元素就是要找的元素
2.使用一个 count 来计数，当是同一个值时，count +1，否则 count -1，因为有一个元素会大于数组长度一半，所以遍历到最后， count 一定会大于0，而那个元素就是目标元素

```javascript
var majorityElement = function(nums) {
  var count = 0;
  var majority = 0;
  for (let i = 0; i < nums.length; i++) {
    if (!count) {
      majority = nums[i];
      count = 1;
    } else {
      count += (nums[i] === majority ? 1 : -1);
    }
  }
  return majority;
}
```

### 206 反转链表
遍历链表，每次取链表一个元素，改动 next 指向

### 226 翻转二叉树
先进行左右节点互换， 然后再对左右节点进行递归

### 234 回文链表
1.获取一个反向链表，进行对比，看看两个链表是否一致
2.快慢指针找出中点， 然后再反转后半部分链表，进行对比

### 283 移动零
1.遍历，然后把splice 值为零的元素， 最后再把元素为零的数组逐个 push 到原来数组
2.在原数组操作，当元素大于零时，nums[index] = n, 同时 index++， 最后 index 之前的元素就是非零元素，index 到 length 结尾的全部换成零。

### 448 找到所有数组中消失的数字
1.用对象来存储哪些值用到了，然后再从大到小遍历一遍，找到没有出现在对象中的值
2.没理解

### 461 汉明距离
先对两个数做异或运算， 然后使用 toString(2)，来获取2进制的值，然后把零去掉，字符串长度就是汉明距离

### 543 二叉树的直径
递归左右孩子节点，然后 + 1， 最后返回左右节点深度之和

### 617 合并二叉树
递归节点，进行值的想加即可

-----------------------------难度分割线-----------------------

### 2 两数相加
遍历链表，逐个的对链表元素进行添加，如果需要进位则进位。 需要灵活的设置变量的值，以方便快速计算

### 3 无重复字符的最长子串
利用滑动窗口的思路解题， 双指针，一个左指针， 一个右指针， 遍历， 如果新增的字符在字符串中不存在，则右指针+1，str.slice(left, i + 1), 如果存在，则跳到存在的字母的索引+1处， str.slice(left, i).indexOf(str[i]) + 1; 每次变更均把最大长度与当前子串长度对比。

### 5 最长回文子串
1.暴力破解， 遍历循环， 判断是否是回文
2.动态规划，不会

###  11 盛最多水的容器
遍历， 双指针， 一个起点， 一个终点，比较两者大小，哪个小，那个就移一位同时取小的值， 算体积， 返回体积最大的值

### 15 三数之和
数组先排序， 从小到大， 遍历，先固定一位数， 然后利用双指针， 去计算出三数之和为零的组合，当 nums[i] > 0的时候就可以结束循环了， 因为从小到达， 如果最小的值为正，则没有组合了。 另外遍历 nums.length - 2 即可， 因为需要三个元素

### 17 电话号码的字母组合
递归， 先建立一个数字与对应的数组，数组包含对应的字母。 然后每次取传参的第一位，与剩下的参数进行双层遍历

### 19 删除链表的倒数第 n 个节点
使用快慢指针的方法，来定位链表的位置。 设置空节点，方便对链表进行操作。

### 22 括号生成
利用 DFS 的技巧，遍历所有的可能，把满足条件的结果都记录下来

### 33 搜索旋转排序数组
使用二分法， 需要区分有序数组和无序数组，定为到位置

### 31 下一个排列

### 34 在排序数组中茶盅元素的第一个和最后一个位置
使用二分法， 关键在于找到目标之后不中止，而是继续进行二分法，记录 leftIndex 和 rightIndex

### 39 组合总和
回溯法， 画出对应的树，每次迭代每一个路径

### 46 全排列
深度遍历， 需要一个 temp 储存每次存储的值，当深度和数组长度相等时， 添加到 result 中

### 48 旋转图像

### 49 字母异位词分组
1.异位词判断 str.split('').sort().join('')
2.桶排序，用26字母长度的数组来表示对应的字母，利用 hash 的特性， 最后返回对应的值

### 55 跳跃游戏

### 56 合并区间
双指针解题，要点： 取当前 i 的前一个元素 pre， 与 intervals[i] 对比， 如果 intervals[i][0] <= pre[1]，说明需要进行合并， 那么就 Math.min(intervals[i][0], pre[0]), Math.max(intervals[i][1], pre[1])


